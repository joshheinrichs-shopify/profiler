#!/usr/bin/env ruby -w

require "webrick"
require "json"
require "cgi"
require "optparse"
require "socket"

HTTP_ROOT = File.expand_path File.join(__dir__, "..", "dist")

class Source < WEBrick::HTTPServlet::AbstractServlet
  def initialize server, valid_files
    super(server)
    @valid_files = valid_files
  end

  def do_GET request, response
    file = request.path[/(?<=^\/source).*/]
    if @valid_files.include? file
      response.status = 200
      response['Content-Type'] = 'text/plain'
      response.body = File.binread(file)
    else
      response.status = 404
      response['Content-Type'] = 'text/plain'
      response.body = "Not Found"
    end
  end
end

class GetIndex < WEBrick::HTTPServlet::AbstractServlet
  def do_GET request, response
    response.status = 200
    response['Content-Type'] = 'text/html'
    response.body = File.binread(File.join(HTTP_ROOT, "index.html"))
  end
end

class Profile < WEBrick::HTTPServlet::AbstractServlet
  def initialize server, profile, parsed_profile
    super(server)
    @profile = profile
    @parsed_profile = parsed_profile
  end

  def do_GET request, response
    response.status = 200
    response['Content-Type'] = 'text/html'
    response.body = JSON.dump(@parsed_profile)
  end
end

def merge_profiles!(profiles)
  min_start_time = profiles.map { |profile| profile['meta']['startTime'] }.min

  profiles.each do |profile|
    original_start_time = profile['meta']['startTime']
    offset = original_start_time - min_start_time
    profile['meta']['startTime'] = min_start_time
    profile['threads'].each do |thread|
      thread['registerTime'] += offset if thread['registerTime']
      thread['processStartupTime'] += offset if thread['processStartupTime']
      thread['unregisterTime'] += offset if thread['unregisterTime']
      thread['processShutdownTime'] += offset if thread['processShutdownTime']
      thread['samples']['time'].map! { |time| time + offset }
      thread['markers']['startTime'].map! { |time| time ? time + offset : nil }
      thread['markers']['endTime'].map! { |time| time ? time + offset : nil }
    end
  end

  merged_profile = {
    'meta' => profiles[0]['meta'],
    'libs' => profiles.map { |profile| profile['libs'] }.flatten,
    'threads' => profiles.map { |profile| profile['threads'] }.flatten,
  }
  initial_visible_threads = []
  merged_profile['threads'].each_with_index do |thread, index|
    initial_visible_threads << index if thread['isMainThread']
  end
  merged_profile['meta']['initialVisibleThreads'] = initial_visible_threads

  merged_profile
end

options = {
  merge: false,
}
o = OptionParser.new do |opts|
  opts.banner = "Usage: profile-viewer profile.json"

  opts.on("--merge", "Merge profiles") do
    options[:merge] = true
  end

  opts.on("-v", "Show version") do |v|
    require_relative "profile-viewer-version"
    puts "Profile Viewer Version: #{ProfileViewer::VERSION}"
    puts
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end
o.parse!

unless ARGV[0]
  $stderr.puts o
  exit(2)
end

port = 0
profile_paths = []
server = WEBrick::HTTPServer.new :Port => port,
  :DocumentRoot => HTTP_ROOT,
  :StartCallback => lambda {
    port = server.config[:Port]
    profile_paths.each do |path|
      should_get = "http://localhost:#{port}/from-url/" + CGI.escape("http://localhost:#{port}#{path}")
      system("open #{should_get}")
    end
  }

trap 'INT' do server.shutdown end

server.mount "/from-url", GetIndex

profiles = ARGV.map do |profile_path|
  unless File.exist?(profile_path)
    $stderr.puts "no such file #{profile_path}"
    $stderr.puts
    $stderr.puts o
    exit(2)
  end

  is_gzipped = File.binread(profile_path, 2) == "\x1F\x8B".b
  content = if is_gzipped
    require "zlib"
    Zlib::GzipReader.open(profile_path) { |gz| gz.read }
  else
    File.read(profile_path)
  end
  parsed_profile = JSON.parse(content)

  [profile_path, parsed_profile]
end

if options[:merge]
  parsed_profiles = profiles.map { |_, parsed_profile| parsed_profile }
  profiles = [["merge", merge_profiles!(parsed_profiles)]]
end

valid_files = Set.new

profiles.each.with_index do |(profile_path, parsed_profile), index|
  parsed_profile["threads"].each do |thread|
    thread["stringArray"].map! do |str|
      if str.start_with?("/") && File.exist?(str)
        valid_files << str
        "http://localhost:#{port}/source#{str}"
      else
        str
      end
    end
  end

  uri_path = "/profile#{index unless ARGV.size == 1}"
  $stderr.puts "Mounting #{profile_path} at #{uri_path}"
  server.mount uri_path, Profile, profile_path, parsed_profile
  profile_paths << uri_path
end

unless valid_files.empty?
  server.mount "/source", Source, valid_files
end

server.start
